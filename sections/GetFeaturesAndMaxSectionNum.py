import json
import multiprocessing
import os
import time

import pefile


class CustomError(Exception):
    """自定义异常类型的示例"""

    def __init__(self, message):
        self.message = message
        super().__init__(self.message)


def dictSort(dictionary):
    return dict(sorted(dictionary.items(), key=lambda item: item[1], reverse=True))


def fileParse(validPath: str):
    s = time.time()
    try:
        pe = pefile.PE(validPath)  # 加载 PE 文件
        sectionNum = len(pe.sections)
    except CustomError('Can not get section num of ' + validPath + ' using PEFILE'):
        sectionNum = 0

    e = time.time()
    print('files name:', validPath, ", section num:", sectionNum,
          ', time cost:', round(e - s, 6), ', parsed by process:', os.getpid())

    return sectionNum
    # 此时完成1整个二进制文件的n-grams读取，即统计了此样本都存在哪些n-grams，但没有计数出现频数


def GetFeaturesAndMaxSectionNum():
    with open("../config.json") as f:
        configs = json.load(f)

    inWhichDatasets = [configs['malicious_train_samples_path'],
                       configs['benign_train_samples_path'],
                       configs['malicious_validation_samples_path'],
                       configs['benign_validation_samples_path']]

    validPaths = {}
    for root in inWhichDatasets:
        paths = os.listdir(root)
        for path in paths:
            fullPath = os.path.join(root, path)
            validPaths[fullPath] = os.path.getsize(fullPath)
    validPaths = dictSort(validPaths)

    fileParsePool = multiprocessing.Pool(multiprocessing.cpu_count())  # 分配进程数量
    resultAddress = []
    for validPath in validPaths.keys():
        resultAddress.append(fileParsePool.apply_async(fileParse, args=(validPath,)))
    fileParsePool.close()
    fileParsePool.join()

    SectionNums = []
    for address in resultAddress:
        SectionNums.append(address.get())
    MaxSectionNum = max(SectionNums)

    features = ['resource_num',
                "resourcesMaxEntropy", "resourcesMaxSize",
                "resourcesMeanEntropy", "resourcesMeanSize",
                "resourcesMinEntropy", "resourcesMinSize"]

    features += ['sectionsMaxEntropy', 'sectionsMaxSize', 'sectionsMaxVirtualSize',
                 'sectionsMeanEntropy', 'sectionsMeanSize', 'sectionsMeanVirtualSize',
                 'sectionsMinEntropy', 'sectionsMinSize', 'sectionsMinVirtualSize']

    for i in range(MaxSectionNum):
        features.append('Section_' + str(i) + '_exists')
        features.append('Section_' + str(i) + '_name_is_standard')
        features.append('Section_' + str(i) + '_size')
        features.append('Section_' + str(i) + '_phisicalAddress')
        features.append('Section_' + str(i) + '_virtualSize')
        features.append('Section_' + str(i) + '_entropy')
        features.append('Section_' + str(i) + '_numberOfRelocations')
        features.append('Section_' + str(i) + '_pointerToRelocations')
        features += ['Section_' + str(i) + '_bit' + str(index) for index in range(32)]

    # return [features, MaxSectionNum]  # 完整的features列表

    MaxSectionNum = 2  # 为了测试，手动指定此数值
    return [features[:MaxSectionNum*40+7+9], 2]
