import os
import pathlib
import time
import multiprocessing
import csv

import lief
import pefile


class CustomError(Exception):
    """自定义异常类型的示例"""

    def __init__(self, message):
        self.message = message
        super().__init__(self.message)


def dictSort(dictionary):
    return dict(sorted(dictionary.items(), key=lambda item: item[1], reverse=True))


def extract_feature(features: list, validPath: str):
    s = time.time()
    try:
        result = []

        # # pefile版本
        # pe = pefile.PE(validPath)
        # for entry in pe.DIRECTORY_ENTRY_IMPORT:
        #     result.append(entry.dll.decode())  # 因为result是set类型，所以可以在这里去重

        # lief版本
        importTable = lief.PE.parse(validPath)
        for dll in importTable.imports:
            result.append(dll.name)

        featureList = []
        for feature in features:
            featureList.append(1) if feature in result else featureList.append(0)

    except CustomError('Can not extract dlls of ' + validPath + ', fill the features with \'-1\''):
        featureList = [-1] * len(features)

    featureList += [pathlib.Path(validPath).parts[-1]]  # 倒数第二列是name
    # 在train和validation中，存在malicious和benign目录，可以知晓标签
    # 但是在test中没有这两个目录，即不知道标签，所以无法加上标签
    if pathlib.Path(validPath).parts[-2] == 'malicious':
        featureList += [1]  # 倒数第一列是label
    elif pathlib.Path(validPath).parts[-2] == 'benign':
        featureList += [0]  # 倒数第一列是label

    e = time.time()
    print('Extract:', validPath, ' ends, time cost:', round(e - s, 6))
    return featureList


# 此函数主要是为了实现处理malicious和benign时的代码复用
def classParse(features: list, rootPath: str, csvPath: str):
    if os.path.exists(csvPath):
        os.remove(csvPath)

    csvStream = open(csvPath, mode='a', newline='')
    csvWriter = csv.writer(csvStream)

    if pathlib.Path(rootPath).parts[-1] != 'test':  # 说明此时是为训练集或验证集提取特征
        csvWriter.writerow(features + ['name'] + ['label'])  # 此处是bug更改位置
        csvStream.close()  # 由于特征提取过程过慢，所以先关闭文件流
        print('feature columns: ', [features[0], features[1], '...', features[-2], features[-1], 'name', 'label'])
    else:  # 说明此时是为测试集提取特征
        csvWriter.writerow(features + ['name'])
        csvStream.close()  # 由于特征提取过程过慢，所以先关闭文件流
        print('feature columns: ', [features[0], features[1], '...', features[-2], features[-1], 'name'])

    validPaths = {}
    for path in os.listdir(rootPath):
        fullPath = os.path.join(rootPath, path)
        validPaths[fullPath] = os.path.getsize(fullPath)
    validPaths = dictSort(validPaths)  # 降序排列

    extractPool = multiprocessing.Pool(multiprocessing.cpu_count())  # 分配进程数量
    csvRows = []
    for validPath in validPaths.keys():
        csvRows.append(extractPool.apply_async(extract_feature, args=(features, validPath)))
    extractPool.close()
    extractPool.join()

    csvStream = open(csvPath, mode='a', newline='')
    csvWriter = csv.writer(csvStream)
    for row in csvRows:
        csvWriter.writerow(row.get())
    csvStream.close()
