import multiprocessing
import time
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import f1_score
import joblib
import pandas as pd
import os


def train(trainPath: str, validationPath: str, modelOutputPath: str):
    trainData = pd.read_csv(trainPath)
    trainData = trainData.fillna(trainData.mean(numeric_only=True))
    X_train = trainData.iloc[:, :-2].values  # 暂时不需要名称列
    y_train = trainData.iloc[:, -1].values.astype(int)  # 确保分类任务的标签是离散的int，而不是不是连续值

    validationData = pd.read_csv(validationPath)
    validationData = validationData.fillna(validationData.mean(numeric_only=True))
    X_validation = validationData.iloc[:, :-2].values  # 暂时不需要名称列
    y_validation = validationData.iloc[:, -1].values.astype(int)  # 确保分类任务的标签是离散的int，而不是不是连续值

    # train_test_split(data, label, test_size=0.2, random_state=42)

    print('features shape in Train:', X_train.shape, ',features shape in Validation', X_validation.shape,
          ';label shape in Train:', y_train.shape, ',label shape in Validation:', y_validation.shape)

    maxF1 = 0.0
    lastF1 = 0.0
    for estimator in [50, 80, 90, 100, 110, 120, 150]:
        for max_depth in [None, 10, 20, 50, 100]:
            for bootstrap in [True, False]:
                s = time.time()
                rf_model = RandomForestClassifier(n_estimators=estimator, max_depth=max_depth, bootstrap=bootstrap,
                                                  n_jobs=multiprocessing.cpu_count())
                rf_model.fit(X_train, y_train)
                predictions = rf_model.predict(X_validation)
                currentF1 = round(f1_score(y_validation, predictions), 6)

                e = time.time()
                if currentF1 > maxF1:
                    maxF1 = currentF1
                    print("Current F1 = ", currentF1, ', last F1 = ', lastF1, ', parameters:',
                          'n_estimators = ', estimator, ', max_depth = ', max_depth, ', bootstrap = ', bootstrap,
                          ', time cost:',
                          round(e - s, 6))
                    print(
                        '***Additional information: this is a better hyperparameter tuple, keep this model***')
                    print()

                    if os.path.exists(modelOutputPath):
                        os.remove(modelOutputPath)
                    joblib.dump(rf_model, modelOutputPath)  # 保存模型

                else:
                    print("Current F1 = ", currentF1, ', last F1 = ', lastF1, ', parameters:',
                          'n_estimators = ', estimator, ', max_depth = ', max_depth, ', bootstrap = ', bootstrap,
                          ', time cost:',
                          round(e - s, 6))
                    print()

                lastF1 = currentF1


def main():
    train(r'csvResult/train.csv', 'csvResult/validation.csv', r'checkpoint/checkpoint_best.joblib')


if __name__ == '__main__':
    main()
