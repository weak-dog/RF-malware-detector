import pandas as pd
from pandas import DataFrame
import os
import numpy as np


def csvContactDim0(csv1Path: str, csv2Path: str, outputPath: str):
    """
    纵向(函数名中的Dim0)合并两个csv文件，主要用来合并mal和ben
    csv1Path：csv路径1
    csv2Path：csv路径2
    outputPath；保存结果的路径
    """
    # 指定header=None相当于把header行作为最普通的一行
    # 此时，当访问csv.columns时显示的是行号[0, 1, ...]这样的
    up = pd.read_csv(csv1Path, header=None)
    columnName = up.iloc[0, :].values.tolist()
    upValues = up.iloc[1:, :].values
    downValues = pd.read_csv(csv2Path, header=None).iloc[1:, :].values
    final = np.concatenate([upValues, downValues], axis=0)
    final = pd.DataFrame(final, columns=columnName)
    if os.path.exists(outputPath):
        os.remove(outputPath)
    final.to_csv(outputPath, index=False)


def csvContactDim1Base(csv1: DataFrame, csv2: DataFrame, whereIsNameColumn: int):
    exceptLength = len(csv1.columns) + len(csv2.columns) + whereIsNameColumn  # -2是因为两个csv都有name和label，但是只需要保留一份即可
    names1 = csv1.iloc[:, whereIsNameColumn].values.tolist()  # 获取倒数第二列的名称列，是合并的主键
    names2 = csv2.iloc[:, whereIsNameColumn].values.tolist()  #

    indexes = [names2.index(name) for name in names1]
    buffer = [csv2.iloc[index, :whereIsNameColumn].values for index in indexes]

    leftValues = csv1.iloc[:, :whereIsNameColumn]  # df类型
    rightValues = pd.DataFrame(buffer, columns=csv2.columns[:whereIsNameColumn])  # 请确保列名是csv2的
    NameLabel = csv1.iloc[:, whereIsNameColumn:]  # df类型

    final = pd.concat([leftValues, rightValues, NameLabel], axis=1)  # axis=1横向合并
    assert len(final.columns) == exceptLength
    return final


def csvContactDim1Instance(csvDirectory: str, outputPath: str, whereIsNameColumn: int):
    """
    横向(函数名里的Dim1)合并一个目录下的所有csv文件，，主要用来相同label的不同特征
    csvDirectory：csv存放目录
    outputPath：保存结果的路径
    whereIsNameColumn：指用于合并的主键，即name列在csv中的位置
    """
    # csvPaths = os.listdir(csvDirectory)
    # 手动指定顺序
    csvPaths = ["headers.csv", "sections.csv", "files.csv", "dlls.csv",
                "imports.csv", "strings.csv", "byteGrams.csv", "opcodeGrams.csv", ]
    csv1 = pd.read_csv(os.path.join(csvDirectory, csvPaths[0]))
    for i in range(1, len(csvPaths)):
        csv2 = pd.read_csv(os.path.join(csvDirectory, csvPaths[i]))
        csv1 = csvContactDim1Base(csv1, csv2, whereIsNameColumn)  # 递归调用Base方法
    if os.path.exists(outputPath):
        os.remove(outputPath)
    csv1.to_csv(outputPath, index=False)


def main():
    root = r'validation/'
    # 递归合并validation/mal目录下的所有csv文件，并存放在validation目录下。Dim1指的是左右拼接，-2指的是name列位于csv的倒数第二列。
    csvContactDim1Instance(root + 'malCSV', root + 'mal.csv', -2)
    # 同上，不过是递归合并validation/benign目录下的所有csv文件
    csvContactDim1Instance(root + 'benCSV', root + 'ben.csv', -2)
    # 将上两步存放在validation目录下的两个csv进行上下拼接(Dim0)，然后存放在csvResult目录下，这样得到了最终的validation.csv
    csvContactDim0(root + 'mal.csv', root + 'ben.csv', root[:-1] + '.csv')

    root = r'train/'
    csvContactDim1Instance(root + 'malCSV', root + 'mal.csv', -2)
    csvContactDim1Instance(root + 'benCSV', root + 'ben.csv', -2)
    csvContactDim0(root + 'mal.csv', root + 'ben.csv', root[:-1] + '.csv')

    root = r'test/'
    csvContactDim1Instance(root, root[:-1] + '.csv', -1)  # 显然test只需要进行左右拼接即可
